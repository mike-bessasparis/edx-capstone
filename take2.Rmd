---
title: "R Notebook"
output: html_notebook
---

``` {r}
library(tidyverse)
library(caret)


#edx <- readRDS(file = "./rda/full_edx.rds")
#validation <- readRDS (file = "./rda/full_Validation.rds")

edx <- readRDS(file = "./rda/small_edx.rds")
validation <- readRDS (file = "./rda/small_Validation.rds")

#edx <- readRDS(file = "./rda/mini_edx.rds")
#validation <- readRDS (file = "./rda/mini_Validation.rds")


```


``` {r}

train_set <- edx
test_set <- validation

RMSE <- function(true_ratings, predicted_ratings) {
  sqrt(mean((true_ratings - predicted_ratings)^2))
}

rm(edx, validation)

```

## Feature Engineering (from EDA)
Lambdas tuned by cross-validation
``` {r}
library(lubridate)

# factorize userId and movieId
# create a reviewed_date and reviewed_year feature
train_set <- train_set %>%
  mutate(#userId = factor(userId),
         #movieId = factor(movieId),
         review_date = date(as_datetime(timestamp)),
         review_year = year(review_date))
test_set <- test_set %>%
  mutate(#userId = factor(userId),
         #movieId = factor(movieId),
         review_date = date(as_datetime(timestamp)),
         review_year = year(review_date))

mu <- mean(train_set$rating)

# find b_i(t), the rating bias for each movie as a function of time (year)
lambda1 <- 3
movie_time_bias <- train_set %>% 
  group_by(movieId, review_year) %>% 
  summarize(b_i_time = sum(rating - mu) / (n() + lambda1))
train_set <- left_join(train_set, movie_time_bias, by = c("movieId", "review_year"))

# find the user rating bias for each user
lambda2 <- 5
user_bias <- train_set %>% 
  group_by(userId) %>% 
  summarize(b_u = sum(rating - mu - b_i_time) / (n() + lambda2) )
train_set <- left_join(train_set, user_bias, by = "userId")



# create released_year and movie_age_at_rating features
train_set <- train_set %>%
  mutate(movie_release_year = as.integer(str_extract(str_extract(title, "\\(\\d{4}\\)"), "\\d{4}")),
         movie_age_at_rating = year(review_date) - movie_release_year)
test_set <- test_set %>%
  mutate(movie_release_year = as.integer(str_extract(str_extract(title, "\\(\\d{4}\\)"), "\\d{4}")),
         movie_age_at_rating = year(review_date) - movie_release_year)



# Create the number of times a movie has been reviewed predictor
q <- train_set %>% 
  group_by(movieId) %>% 
  summarise(num_of_reviews_of_movie = n())

train_set <- train_set %>%
  left_join(q, by = "movieId")
test_set <- test_set %>% 
  left_join(q, by = "movieId")


# create df to individual model predictions
ensemble_preds <- test_set %>% 
  select(userId, movieId)

rm(lambda1, lambda2, q)

```

## Custom Model (Netflix)
``` {r}

# r = mu + b_i(t) + b_u

# add movie and user bias calculated from the train_set and make predictions
# mutate is to put 0 where we don't have a calculated movie_time_bias
pred_custom <- test_set %>% 
  left_join(movie_time_bias, by = c("movieId", "review_year")) %>% 
  mutate(b_i_time = if_else(is.na(b_i_time), 0, b_i_time)) %>%   
  left_join(user_bias, by = "userId") %>% 
  mutate(pred_c = mu + b_i_time + b_u)

# recover predictions outside of rating range
pred_custom <- pred_custom %>% 
  select(userId, movieId, pred_c) %>% 
  mutate(pred_c = if_else(pred_c > 5, 5, pred_c),
         pred_c = if_else(pred_c < 0.5, 0.5, pred_c))

RMSE_cust <- RMSE(test_set$rating, pred_custom$pred_c)

ensemble_preds <- ensemble_preds %>% 
  left_join(pred_custom, by = c("userId", "movieId"))

#rm(movie_time_bias, user_bias, mu)

```

## XGBoost
``` {r}

fitControl <- trainControl(method = "cv", number = 3)

xgbGrid <- expand.grid(gamma = 0,
                       min_child_weight = 1,
                       nrounds = 300,
                       max_depth = 7,
                       eta = 0.3,
                       colsample_bytree = 0.8,
                       subsample = 1)

start <- Sys.time()

fit <- train(rating ~ b_u + b_i_time + movie_age_at_rating + num_of_reviews_of_movie,
             data = train_set,
             method = "xgbTree",
             tuneGrid = xgbGrid,
             trControl = fitControl,
             preProcess = c("center", "scale"))

end <-Sys.time()
mjb <- end - start

test_set_working <- test_set %>% 
  select(-rating) %>% 
  left_join(movie_time_bias, by = c("movieId", "review_year")) %>% 
  mutate(b_i_time = if_else(is.na(b_i_time), 0, b_i_time)) %>%   
  left_join(user_bias, by = "userId")

q <- predict(fit, test_set_working)

pred_xgb <- data.frame(userId = test_set$userId, movieId = test_set$movieId, pred_x = q)

# recover predictions outside of rating range
pred_xgb <- pred_xgb %>% 
  mutate(pred_x = if_else(pred_x > 5, 5, pred_x),
         pred_x = if_else(pred_x < 0.5, 0.5, pred_x))

RMSE_xgb <- RMSE(test_set$rating, pred_xgb$pred_x)

ensemble_preds <- ensemble_preds %>% 
  left_join(pred_xgb, by = c("userId", "movieId"))


```


## Neural Network
```{r}

fitControl <- trainControl(method = "cv", number = 2)
nnetGrid <- expand.grid(size = 3,
                       decay = 1e-4)

start <- Sys.time()

fit <- train(rating ~ b_u + b_i_time + num_of_reviews_of_movie,
             data = train_set,
             method = "nnet",
             trControl = fitControl, 
             tuneGrid = nnetGrid,
             preProcess = c("center", "scale"),
             linout = TRUE)

end <-Sys.time()
mjb <- end - start

test_set_working <- test_set %>% 
  select(-rating) %>% 
  left_join(movie_time_bias, by = c("movieId", "review_year")) %>% 
  mutate(b_i_time = if_else(is.na(b_i_time), 0, b_i_time)) %>%   
  left_join(user_bias, by = "userId")

q <- predict(fit, test_set_working)

pred_nnet <- data.frame(userId = test_set$userId, movieId = test_set$movieId, pred_n = q)

# recover predictions outside of rating range
pred_nnet <- pred_nnet %>% 
  mutate(pred_n = if_else(pred_n > 5, 5, pred_n),
         pred_n = if_else(pred_n < 0.5, 0.5, pred_n))

RMSE_nnet <- RMSE(test_set$rating, pred_nnet$pred)

ensemble_preds <- ensemble_preds %>% 
  left_join(pred_nnet, by = c("userId", "movieId"))

```

## Use ensemble to create final predictions
```{r}

ensemble_preds <- ensemble_preds %>% 
  mutate (final_pred = (pred_c + pred_x + pred_n) / 3)

RMSE_ensemble <- RMSE(test_set$rating, ensemble_preds$final_pred)

```

