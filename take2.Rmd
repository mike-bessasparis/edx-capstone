---
title: "R Notebook"
output: html_notebook
---

``` {r}
library(tidyverse)
library(caret)


edx <- readRDS(file = "./rda/full_edx.rds")
validation <- readRDS (file = "./rda/full_Validation.rds")

#edx <- readRDS(file = "./rda/small_edx.rds")
#validation <- readRDS (file = "./rda/small_Validation.rds")

#edx <- readRDS(file = "./rda/mini_edx.rds")
#validation <- readRDS (file = "./rda/mini_Validation.rds")


```


``` {r}

train_set <- edx
test_set <- validation

RMSE <- function(true_ratings, predicted_ratings) {
  sqrt(mean((true_ratings - predicted_ratings)^2))
}

rm(edx, validation)

```

## Feature Engineering (from EDA)
``` {r}
library(lubridate)

# factorize userId and movieId
# create a reviewed_date and reviewed_year feature
train_set <- train_set %>%
  mutate(userId = factor(userId),
         movieId = factor(movieId),
         review_date = date(as_datetime(timestamp)),
         review_year = year(review_date))
test_set <- test_set %>%
  mutate(userId = factor(userId),
         movieId = factor(movieId),
         review_date = date(as_datetime(timestamp)),
         review_year = year(review_date))

mu <- mean(train_set$rating)



# find b_i(t), the rating bias for each movie as a function of time (year)
lambda1 <- 3
movie_time_bias <- train_set %>% 
  group_by(movieId, review_year) %>% 
  summarize(b_i_time = sum(rating - mu) / (n() + lambda1))
train_set <- left_join(train_set, movie_time_bias, by = c("movieId", "review_year"))

# find the user rating bias for each user
lambda2 <- 5
user_bias <- train_set %>% 
  group_by(userId) %>% 
  summarize(b_u = sum(rating - mu - b_i_time) / (n() + lambda2) )
train_set <- left_join(train_set, user_bias, by = "userId")



# create released_year and movie_age_at_rating features
train_set <- train_set %>%
  mutate(movie_release_year = as.integer(str_extract(str_extract(title, "\\(\\d{4}\\)"), "\\d{4}")),
         movie_age_at_rating = year(review_date) - movie_release_year)
test_set <- test_set %>%
  mutate(movie_release_year = as.integer(str_extract(str_extract(title, "\\(\\d{4}\\)"), "\\d{4}")),
         movie_age_at_rating = year(review_date) - movie_release_year)



# Create the number of times a movie has been reviewed predictor
q <- train_set %>% 
  group_by(movieId) %>% 
  summarise(num_of_reviews_of_movie = n())

train_set <- train_set %>%
  left_join(q, by = "movieId")
test_set <- test_set %>% 
  left_join(q, by = "movieId")



# train_set <- train_set %>% 
#   select(-genres, -title, -timestamp)
# test_set <- test_set %>% 
#   select(-genres, -title, -timestamp)


```



## Custom Model (Netflix)
``` {r}

# r = mu + b_i(t) + b_u

# add movie and user bias calculated from the train_set and make predictions
# mutate is to put 0 where we don't have a calculated movie_time_bias
custom_predicted_ratings <- test_set %>% 
  left_join(movie_time_bias, by = c("movieId", "review_year")) %>% 
  mutate(b_i_time = if_else(is.na(b_i_time), 0, b_i_time)) %>%   
  left_join(user_bias, by = "userId") %>% 
  mutate(pred = mu + b_i_time + b_u)

# recover predictions outside of rating range
custom_predicted_ratings <- custom_predicted_ratings %>% 
  select(userId, movieId, pred) %>% 
  mutate(pred = if_else(pred > 5, 5, pred),
         pred = if_else(pred < 0.5, 0.5, pred))

RMSE_cust <- RMSE(test_set$rating, custom_predicted_ratings$pred)

#ggplot(data = test_set, aes(x = test_set$rating, y = predicted_ratings$pred)) +
#       geom_point()

#rm(movie_time_bias, predicted_ratings, user_bias, lambda1, lambda2, mu)

```

## XGBoost
``` {r eval=FALSE}

fitControl <- trainControl(method = "cv", number = 3)

xgbGrid <- expand.grid(gamma = 0,
                       min_child_weight = 1,
                       nrounds = 300,
                       max_depth = 7,
                       eta = 0.3,
                       colsample_bytree = 0.8,
                       subsample = 1)

start <- Sys.time()

fit <- train(rating ~ b_u + b_i_time,
             data = train_set,
             method = "xgbTree",
             tuneGrid = xgbGrid,
             trControl = fitControl,
             preProcess = c("center", "scale"))

end <-Sys.time()
mjb <- end - start

test_set_working <- test_set %>% 
  select(-rating) %>% 
  left_join(movie_time_bias, by = c("movieId", "review_year")) %>% 
  mutate(b_i_time = if_else(is.na(b_i_time), 0, b_i_time)) %>%   
  left_join(user_bias, by = "userId")

q <- predict(fit, test_set_working)

pred_xgb <- data.frame(userId = test_set$userId, movieId = test_set$movieId, pred = q)

# recover predictions outside of rating range
pred_xgb <- pred_xgb %>% 
  mutate(pred = if_else(pred > 5, 5, pred),
         pred = if_else(pred < 0.5, 0.5, pred))

RMSE_xgb <- RMSE(test_set$rating, pred_xgb$pred)


```


## Neural Network
```{r}

fitControl <- trainControl(method = "cv", number = 2)
nnetGrid <- expand.grid(size = 3,
                       decay = 1e-4)

start <- Sys.time()

fit <- train(rating ~ b_u + b_i_time,
             data = train_set,
             method = "nnet",
             trControl = fitControl, 
             tuneGrid = nnetGrid,
             preProcess = c("center", "scale"),
             linout = TRUE)

end <-Sys.time()
mjb <- end - start

test_set_working <- test_set %>% 
  select(-rating) %>% 
  left_join(movie_time_bias, by = c("movieId", "review_year")) %>% 
  mutate(b_i_time = if_else(is.na(b_i_time), 0, b_i_time)) %>%   
  left_join(user_bias, by = "userId")

q <- predict(fit, test_set_working)

pred_nnet <- data.frame(userId = test_set$userId, movieId = test_set$movieId, pred = q)

# recover predictions outside of rating range
pred_nnet <- pred_nnet %>% 
  mutate(pred = if_else(pred > 5, 5, pred),
         pred = if_else(pred < 0.5, 0.5, pred))

RMSE_nnet <- RMSE(test_set$rating, pred_nnet$pred)

```

