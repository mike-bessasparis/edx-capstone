---
title: "Report"
output: html_notebook
---

```{r}

library(tidyverse)
library(readr)
library(ggthemes)
library(gridExtra)
library(kableExtra)
library(corrplot)
library(lubridate)
library(caret)

edx <- readRDS(file = "./rda/edx.rds")
validation <- readRDS (file = "./rda/Validation.rds")

small_edx <- sample_n(edx, 1000)

```

***
# Explore variables
```{r}

summary(edx)

head(edx)

```

## Response Variable: Rating
```{r}

summary(edx$rating)

```

```{r}

edx %>% ggplot(aes(x=rating)) +
  geom_histogram(binwidth = .5, col="grey") +
  scale_x_continuous(breaks = seq(0, 5, .5)) +
  theme_economist_white()

edx %>% ggplot(aes(x=rating)) +
  geom_histogram(binwidth = 1, col="grey") +
  theme_economist_white()


```
## Other interesting variables
```{r}

#Find number of unique movies rated, number of unique users, and number of movies in each genre.

mjb1 <- length(unique(edx$movieId))
mjb2 <- length(unique(edx$userId))

mjb3 <- edx %>% separate_rows(genres, sep = "\\|") %>% 
  group_by(genres) %>% 
  summarise(count = n()) %>% 
  arrange(-count)

mjb4 <- nrow(mjb3)

```
In the dataset there are: 

- `r mjb2` unique users
- `r mjb1` unique movies rated
- `r mjb4` unique movie genres

Movies grouped by genre.  Note that a movie may be tagged with several genres, e.g., the movie "Boomerang" is classified as both a "Comedy" and a "Romance."
```{r}

mjb3 %>% ggplot() +
  geom_col(aes(x = reorder(genres, -count), y = count)) +
  coord_flip() +
  xlab("Genre") +
  ylab("Number of Movies") +
  theme_economist_white() +
  theme(axis.text.y.left = element_text(hjust = 1),
        panel.grid.major = element_blank(),
        axis.ticks.y.left = element_line(),
        axis.ticks.x.bottom = element_blank())

```

```{r}

edx %>% filter(genres == "(no genres listed)")

```



What are the top 10 most reviewed movies?
```{r}

edx %>% 
  group_by(title) %>% 
  summarise(count = n()) %>% 
  arrange(-count) %>% 
  top_n(10)

```
Who are the top 10 active reviewers?
```{r}

edx %>% 
  group_by(userId) %>% 
  summarise(count = n()) %>% 
  arrange(-count) %>% 
  top_n(10)

```
***
# Relationships (part 1)
## Numeric Correlations with Rating
No continuous numeric predictors to correlate with Rating; userId and movieId are discrete while timestamp is a date.

*** 
# Missing data, label encoding, and factorizing variables
```{r}
#
# make a copy of the data to modify so I don't have to rebuild if something goes bad.
#
edx2 <- edx

#
# First of all, I would like to see which variables contain missing values.
#
NAcol <- which(colSums(is.na(edx2)) > 0)

```

There are `r length(NAcol)` columns with at least one NA.

```{r}

# Label encoding
# There are no labels that are ordinal and should be encoded as a number.

#
# Factorizing variables
#
# edx2 <- edx2 %>% 
#   mutate(rating = factor(rating))

edx2 <- edx2 %>% 
  separate_rows(genres, sep = "\\|") %>% 
  mutate(genres = factor(genres))

edx2 %>% filter(genres == "(no genres listed)")
# "Pull My Daisy (1958)" by Kerouac
# IMDB lists the genre as "Short"


#
# Transform "timestamp" into a datetime object
#
edx2 <- edx2 %>% 
  mutate(timestamp = as_datetime(timestamp))

```

***
# Relationships (part 2)
```{r}

#genre and rating
edx2 %>% 
  group_by(genres) %>% 
  summarise(avg_rating = mean(rating))%>% 
  arrange(-avg_rating) %>% 
  ggplot() +
    geom_point(aes(y = reorder(genres, -avg_rating), x = avg_rating)) +
    xlim(0, 5)

# do users have extreme views of each genre
user_genre_affinity <- edx2 %>% 
  group_by(userId, genres) %>% 
  summarise(avg_rating = mean(rating)) %>% 
  filter(avg_rating < 1 | avg_rating > 4.75)

user_genre_affinity %>% ggplot() +
    geom_raster(aes(y = genres, x = userId, fill = avg_rating)) +
    scale_fill_distiller(palette = "Spectral")


```

Average rating of each user.  Red represents a user who rated all movies the same (sd == 0).
```{r}
# user and rating
mjb1 <- edx %>% 
  group_by(userId) %>% 
  summarise(avg_rating = mean(rating), std_dev = sd(rating))%>% 
  arrange(-avg_rating)

outliers <- mjb1 %>% 
  filter(std_dev == 0)

ggplot() +
  geom_point(data = mjb1, aes(x = userId, y = avg_rating), color = "grey") +
  geom_point(data = outliers, aes(x = userId, y = avg_rating), color = "red")  

```
Let's look at the ratings of only these users
```{r}

edx %>%
  filter(userId %in% outliers$userId) %>% 
  ggplot() +
    geom_point(aes(x = as.factor(reorder(userId, rating)), y = rating))

```


# Models

```{r}

#
# Setup
#
edx <- readRDS(file = "./rda/edx.rds")
small_edx <- sample_n(edx, 10000)


set.seed(1)
test_index <- createDataPartition(y = small_edx$rating, times = 1, p = 0.1, list = FALSE)
train <- small_edx[-test_index,]
temp <- small_edx[test_index,]

# Make sure userId and movieId in validation set are also in train set
validation <- temp %>% 
  semi_join(train, by = "movieId") %>%
  semi_join(train, by = "userId")

# Add rows removed from validation set back into edx set
removed <- anti_join(temp, validation)
train <- rbind(train, removed)

# Learners will develop their algorithms on the edx set
# For grading, learners will run algorithm on validation set to generate ratings
# validation <- validation %>% select(-rating)

rm(test_index, temp, removed, edx, small_edx)

#write.csv(train, file="train.csv")
#write.csv(validation, file="validation.csv")

```

```{r}
library(rpart)

fit <- train(rating ~ movieId,
             method="rpart",
             data=train)
fit

ggplot(fit, highlight = TRUE)

plot(fit$finalModel, margin=.1)
text(fit$finalModel, cex=.75)

y_hat <- round(predict(fit, validation, type="raw") / .5) * .5

RMSE(y_hat, validation$rating)

round

```

